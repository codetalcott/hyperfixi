/**
 * Code Generation Script
 *
 * Generates TypeScript types and metadata from behavior schemas.
 * Run with: npx tsx scripts/generate.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// ESM compatibility
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Import all schemas
import { draggableSchema } from '../src/schemas/draggable.schema.js';
import { sortableSchema } from '../src/schemas/sortable.schema.js';
import { resizableSchema } from '../src/schemas/resizable.schema.js';
import { removableSchema } from '../src/schemas/removable.schema.js';
import { toggleableSchema } from '../src/schemas/toggleable.schema.js';
import type { BehaviorSchema, BehaviorCategory, BehaviorTier } from '../src/schemas/types.js';

const schemas: BehaviorSchema[] = [
  draggableSchema,
  sortableSchema,
  resizableSchema,
  removableSchema,
  toggleableSchema,
];

const GENERATED_DIR = path.join(__dirname, '../src/generated');

// Ensure generated directory exists
if (!fs.existsSync(GENERATED_DIR)) {
  fs.mkdirSync(GENERATED_DIR, { recursive: true });
}

/**
 * Generate types.ts
 */
function generateTypes(): void {
  const behaviorNames = schemas.map((s) => s.name);

  // Group by category
  const byCategory: Record<BehaviorCategory, string[]> = {
    ui: [],
    data: [],
    animation: [],
    form: [],
    layout: [],
  };

  // Group by tier
  const byTier: Record<BehaviorTier, string[]> = {
    core: [],
    common: [],
    optional: [],
  };

  for (const schema of schemas) {
    byCategory[schema.category].push(schema.name);
    byTier[schema.tier].push(schema.name);
  }

  const content = `/**
 * Generated Types
 *
 * DO NOT EDIT - Generated by scripts/generate.ts
 * Run \`npm run generate\` to regenerate.
 */

/**
 * Union of all behavior names.
 */
export type BehaviorName = ${behaviorNames.map((n) => `'${n}'`).join(' | ')};

/**
 * UI category behaviors.
 */
export type UIBehavior = ${byCategory.ui.length ? byCategory.ui.map((n) => `'${n}'`).join(' | ') : 'never'};

/**
 * Data category behaviors.
 */
export type DataBehavior = ${byCategory.data.length ? byCategory.data.map((n) => `'${n}'`).join(' | ') : 'never'};

/**
 * Animation category behaviors.
 */
export type AnimationBehavior = ${byCategory.animation.length ? byCategory.animation.map((n) => `'${n}'`).join(' | ') : 'never'};

/**
 * Form category behaviors.
 */
export type FormBehavior = ${byCategory.form.length ? byCategory.form.map((n) => `'${n}'`).join(' | ') : 'never'};

/**
 * Layout category behaviors.
 */
export type LayoutBehavior = ${byCategory.layout.length ? byCategory.layout.map((n) => `'${n}'`).join(' | ') : 'never'};

/**
 * Core tier behaviors (always loaded).
 */
export type CoreBehavior = ${byTier.core.length ? byTier.core.map((n) => `'${n}'`).join(' | ') : 'never'};

/**
 * Common tier behaviors (high usage).
 */
export type CommonBehavior = ${byTier.common.length ? byTier.common.map((n) => `'${n}'`).join(' | ') : 'never'};

/**
 * Optional tier behaviors (load on demand).
 */
export type OptionalBehavior = ${byTier.optional.length ? byTier.optional.map((n) => `'${n}'`).join(' | ') : 'never'};
`;

  fs.writeFileSync(path.join(GENERATED_DIR, 'types.ts'), content);
  console.log('Generated: src/generated/types.ts');
}

/**
 * Generate metadata.ts
 */
function generateMetadata(): void {
  // Group by category
  const byCategory: Record<BehaviorCategory, string[]> = {
    ui: [],
    data: [],
    animation: [],
    form: [],
    layout: [],
  };

  // Group by tier
  const byTier: Record<BehaviorTier, string[]> = {
    core: [],
    common: [],
    optional: [],
  };

  for (const schema of schemas) {
    byCategory[schema.category].push(schema.name);
    byTier[schema.tier].push(schema.name);
  }

  const content = `/**
 * Generated Metadata
 *
 * DO NOT EDIT - Generated by scripts/generate.ts
 * Run \`npm run generate\` to regenerate.
 */

import type { BehaviorCategory, BehaviorTier } from '../schemas/types';
import type { BehaviorName } from './types';

/**
 * All behavior names.
 */
export const ALL_BEHAVIOR_NAMES: BehaviorName[] = ${JSON.stringify(schemas.map((s) => s.name), null, 2)};

/**
 * Behaviors grouped by category.
 */
export const BEHAVIORS_BY_CATEGORY: Record<BehaviorCategory, BehaviorName[]> = ${JSON.stringify(byCategory, null, 2)};

/**
 * Behaviors grouped by tier.
 */
export const BEHAVIORS_BY_TIER: Record<BehaviorTier, BehaviorName[]> = ${JSON.stringify(byTier, null, 2)};

/**
 * Category for each behavior.
 */
export const BEHAVIOR_CATEGORIES: Record<BehaviorName, BehaviorCategory> = ${JSON.stringify(
    Object.fromEntries(schemas.map((s) => [s.name, s.category])),
    null,
    2
  )};

/**
 * Tier for each behavior.
 */
export const BEHAVIOR_TIERS: Record<BehaviorName, BehaviorTier> = ${JSON.stringify(
    Object.fromEntries(schemas.map((s) => [s.name, s.tier])),
    null,
    2
  )};
`;

  fs.writeFileSync(path.join(GENERATED_DIR, 'metadata.ts'), content);
  console.log('Generated: src/generated/metadata.ts');
}

/**
 * Generate index.ts
 */
function generateIndex(): void {
  const content = `/**
 * Generated Exports
 *
 * DO NOT EDIT - Generated by scripts/generate.ts
 * Run \`npm run generate\` to regenerate.
 */

export * from './types';
export * from './metadata';
`;

  fs.writeFileSync(path.join(GENERATED_DIR, 'index.ts'), content);
  console.log('Generated: src/generated/index.ts');
}

/**
 * Validate schemas
 */
function validateSchemas(): void {
  const names = new Set<string>();

  for (const schema of schemas) {
    // Check for duplicate names
    if (names.has(schema.name)) {
      throw new Error(`Duplicate behavior name: ${schema.name}`);
    }
    names.add(schema.name);

    // Validate required fields
    if (!schema.name) throw new Error('Schema missing name');
    if (!schema.category) throw new Error(`Schema ${schema.name} missing category`);
    if (!schema.tier) throw new Error(`Schema ${schema.name} missing tier`);
    if (!schema.source) throw new Error(`Schema ${schema.name} missing source`);

    // Validate parameter schemas
    for (const param of schema.parameters) {
      // Warn if boolean default is a string
      if (param.type === 'boolean' && typeof param.default === 'string') {
        console.warn(
          `  Warning: ${schema.name}.${param.name} is type 'boolean' but default is string '${param.default}'`
        );
      }

      // Warn if enum is set but default is not in enum
      if (param.enum && param.default !== undefined) {
        const defaultStr = String(param.default);
        if (!param.enum.includes(defaultStr)) {
          console.warn(
            `  Warning: ${schema.name}.${param.name} default '${defaultStr}' is not in enum [${param.enum.join(', ')}]`
          );
        }
      }
    }
  }

  console.log(`Validated ${schemas.length} schemas`);
}

// Run generation
console.log('Generating behavior types and metadata...\n');

try {
  validateSchemas();
  generateTypes();
  generateMetadata();
  generateIndex();
  console.log('\nGeneration complete!');
} catch (error) {
  console.error('Generation failed:', error);
  process.exit(1);
}
