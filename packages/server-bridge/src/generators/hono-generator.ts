import type { RouteDescriptor, GeneratorOptions, GenerateResult, GeneratedFile } from '../types.js';
import type { RouteGenerator } from './types.js';
import {
  routeMarker,
  todoBlock,
  USER_START,
  USER_END,
  groupRoutesByPrefix,
  groupToFilename,
} from './template-helpers.js';

export class HonoGenerator implements RouteGenerator {
  readonly framework = 'hono';

  generate(routes: RouteDescriptor[], options: GeneratorOptions): GenerateResult {
    const ts = options.typescript !== false;
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];

    if (routes.length === 0) {
      warnings.push('No routes to generate');
      return { files, preserved: [], warnings };
    }

    const groups = groupRoutesByPrefix(routes);

    for (const [groupKey, groupRoutes] of groups) {
      const filename = groupToFilename(groupKey, ts);
      const content = this.generateRouteFile(groupRoutes, groupKey, ts);
      files.push({ path: `routes/${filename}`, content, isNew: true });
    }

    const indexContent = this.generateIndex(groups, ts);
    files.push({ path: `routes/index.${ts ? 'ts' : 'js'}`, content: indexContent, isNew: true });

    return { files, preserved: [], warnings };
  }

  private generateRouteFile(routes: RouteDescriptor[], groupKey: string, ts: boolean): string {
    const lines: string[] = [];

    lines.push(`// Generated by @hyperfixi/server-bridge — DO NOT EDIT scaffold markers`);
    lines.push(`import { Hono } from 'hono';`);
    lines.push('');
    lines.push('const app = new Hono();');
    lines.push('');

    for (const route of routes) {
      lines.push(routeMarker(route));
      lines.push(this.generateHandler(route, ts));
      lines.push('');
    }

    lines.push('export default app;');
    lines.push('');

    return lines.join('\n');
  }

  private generateHandler(route: RouteDescriptor, ts: boolean): string {
    const method = route.method.toLowerCase();
    const lines: string[] = [];

    lines.push(`app.${method}('${route.path}', async (c) => {`);
    lines.push(`  ${USER_START}`);
    lines.push(todoBlock(route, '  '));

    // Destructure path params
    if (route.pathParams.length > 0) {
      for (const param of route.pathParams) {
        lines.push(`  const ${param} = c.req.param('${param}');`);
      }
    }

    // Parse body for POST/PUT/PATCH
    if (
      route.requestBody &&
      route.requestBody.length > 0 &&
      ['POST', 'PUT', 'PATCH'].includes(route.method)
    ) {
      lines.push(`  const body = await c.req.json();`);
      const fieldList = route.requestBody.map(f => f.name).join(', ');
      lines.push(`  const { ${fieldList} } = body;`);
    }

    // Response stub
    if (route.responseFormat === 'json') {
      lines.push(`  return c.json({ message: 'Not implemented' });`);
    } else if (route.responseFormat === 'html') {
      lines.push(`  return c.html('<div>Not implemented</div>');`);
    } else {
      lines.push(`  return c.text('Not implemented');`);
    }

    lines.push(`  ${USER_END}`);
    lines.push(`});`);

    return lines.join('\n');
  }

  private generateIndex(groups: Map<string, RouteDescriptor[]>, ts: boolean): string {
    const lines: string[] = [];

    lines.push(`// Generated by @hyperfixi/server-bridge — DO NOT EDIT`);
    lines.push(`import { Hono } from 'hono';`);

    for (const groupKey of groups.keys()) {
      const filename = groupKey;
      lines.push(`import ${toCamelCase(groupKey)}Routes from './${filename}.js';`);
    }

    lines.push('');
    lines.push('const app = new Hono();');
    lines.push('');

    for (const groupKey of groups.keys()) {
      lines.push(`app.route('/', ${toCamelCase(groupKey)}Routes);`);
    }

    lines.push('');
    lines.push('export default app;');
    lines.push('');

    return lines.join('\n');
  }
}

function toCamelCase(str: string): string {
  return str.replace(/-(\w)/g, (_, c) => c.toUpperCase());
}
