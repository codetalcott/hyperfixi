import type { RouteDescriptor, GeneratorOptions, GenerateResult, GeneratedFile } from '../types.js';
import type { RouteGenerator } from './types.js';
import {
  routeMarker,
  todoBlock,
  USER_START,
  USER_END,
  groupRoutesByPrefix,
  groupToFilename,
} from './template-helpers.js';

export class ExpressGenerator implements RouteGenerator {
  readonly framework = 'express';

  generate(routes: RouteDescriptor[], options: GeneratorOptions): GenerateResult {
    const ts = options.typescript !== false; // default true
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];

    if (routes.length === 0) {
      warnings.push('No routes to generate');
      return { files, preserved: [], warnings };
    }

    const groups = groupRoutesByPrefix(routes);

    // Generate one router file per group
    for (const [groupKey, groupRoutes] of groups) {
      const filename = groupToFilename(groupKey, ts);
      const content = this.generateRouterFile(groupRoutes, groupKey, ts);
      files.push({ path: `routes/${filename}`, content, isNew: true });
    }

    // Generate index file that imports all routers
    const indexContent = this.generateIndex(groups, ts);
    files.push({ path: `routes/index.${ts ? 'ts' : 'js'}`, content: indexContent, isNew: true });

    return { files, preserved: [], warnings };
  }

  private generateRouterFile(routes: RouteDescriptor[], groupKey: string, ts: boolean): string {
    const lines: string[] = [];

    lines.push(`// Generated by @hyperfixi/server-bridge — DO NOT EDIT scaffold markers`);
    lines.push(`import { Router${ts ? ', Request, Response' : ''} } from 'express';`);
    lines.push('');
    lines.push('const router = Router();');
    lines.push('');

    for (const route of routes) {
      lines.push(routeMarker(route));
      lines.push(this.generateHandler(route, ts));
      lines.push('');
    }

    lines.push('export default router;');
    lines.push('');

    return lines.join('\n');
  }

  private generateHandler(route: RouteDescriptor, ts: boolean): string {
    const method = route.method.toLowerCase();
    const params = ts ? '(req: Request, res: Response)' : '(req, res)';
    const lines: string[] = [];

    lines.push(`router.${method}('${route.path}', async ${params} => {`);
    lines.push(`  ${USER_START}`);
    lines.push(todoBlock(route, '  '));

    // Destructure path params
    if (route.pathParams.length > 0) {
      const paramList = route.pathParams.join(', ');
      lines.push(`  const { ${paramList} } = req.params;`);
    }

    // Destructure query params
    if (route.queryParams && route.queryParams.length > 0) {
      const paramList = route.queryParams.map(p => p.name).join(', ');
      lines.push(`  const { ${paramList} } = req.query;`);
    }

    // Destructure body fields for POST/PUT/PATCH
    if (
      route.requestBody &&
      route.requestBody.length > 0 &&
      ['POST', 'PUT', 'PATCH'].includes(route.method)
    ) {
      const fieldList = route.requestBody.map(f => f.name).join(', ');
      lines.push(`  const { ${fieldList} } = req.body;`);
    }

    // Response stub
    if (route.responseFormat === 'json') {
      lines.push(`  res.json({ message: 'Not implemented' });`);
    } else if (route.responseFormat === 'html') {
      lines.push(`  res.send('<div>Not implemented</div>');`);
    } else {
      lines.push(`  res.send('Not implemented');`);
    }

    lines.push(`  ${USER_END}`);
    lines.push(`});`);

    return lines.join('\n');
  }

  private generateIndex(groups: Map<string, RouteDescriptor[]>, ts: boolean): string {
    const lines: string[] = [];

    lines.push(`// Generated by @hyperfixi/server-bridge — DO NOT EDIT`);
    lines.push(`import { Router } from 'express';`);

    for (const groupKey of groups.keys()) {
      const filename = groupKey;
      lines.push(`import ${toCamelCase(groupKey)}Router from './${filename}.js';`);
    }

    lines.push('');
    lines.push('const router = Router();');
    lines.push('');

    for (const groupKey of groups.keys()) {
      lines.push(`router.use(${toCamelCase(groupKey)}Router);`);
    }

    lines.push('');
    lines.push('export default router;');
    lines.push('');

    return lines.join('\n');
  }
}

function toCamelCase(str: string): string {
  return str.replace(/-(\w)/g, (_, c) => c.toUpperCase());
}
