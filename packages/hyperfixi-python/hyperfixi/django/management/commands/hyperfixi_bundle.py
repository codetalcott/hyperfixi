"""
Django management command to scan templates and generate bundle configuration.

Usage:
    python manage.py hyperfixi_bundle
    python manage.py hyperfixi_bundle --output bundle-config.json
    python manage.py hyperfixi_bundle --format summary
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import TYPE_CHECKING

from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.template import engines

from hyperfixi.scanner import Scanner, VALID_COMMANDS, VALID_BLOCKS
from hyperfixi.aggregator import Aggregator

if TYPE_CHECKING:
    from argparse import ArgumentParser


class Command(BaseCommand):
    """Scan Django templates for hyperscript usage and generate bundle config."""

    help = "Scan templates for hyperscript and generate minimal bundle configuration"

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument(
            "--output",
            "-o",
            type=str,
            help="Output file path (default: stdout)",
        )
        parser.add_argument(
            "--format",
            "-f",
            choices=["json", "js-config", "summary"],
            default="json",
            help="Output format (default: json)",
        )
        parser.add_argument(
            "--name",
            type=str,
            default="DjangoAutoGenerated",
            help="Bundle name for generated config",
        )
        parser.add_argument(
            "--extra-commands",
            type=str,
            help="Comma-separated list of extra commands to always include",
        )
        parser.add_argument(
            "--extra-blocks",
            type=str,
            help="Comma-separated list of extra blocks to always include",
        )
        parser.add_argument(
            "--htmx",
            action="store_true",
            help="Enable HTMX integration in generated bundle",
        )
        parser.add_argument(
            "--positional",
            action="store_true",
            help="Always include positional expressions",
        )
        parser.add_argument(
            "--verbose",
            "-v",
            action="count",
            default=0,
            help="Increase verbosity",
        )
        parser.add_argument(
            "paths",
            nargs="*",
            type=str,
            help="Specific directories to scan (default: all template dirs)",
        )

    def handle(self, *args, **options) -> None:
        verbose = options["verbose"]

        self.stdout.write("Scanning templates for hyperscript usage...\n")

        # Get template directories
        template_dirs = self._get_template_dirs(options["paths"])

        if not template_dirs:
            raise CommandError("No template directories found")

        if verbose:
            self.stdout.write(f"Scanning directories: {template_dirs}\n")

        # Create scanner and aggregator
        scanner = Scanner(debug=verbose > 1)
        aggregator = Aggregator()

        # Scan all directories
        for dir_path in template_dirs:
            usage_map = scanner.scan_directory(dir_path)
            for file_path, usage in usage_map.items():
                aggregator.add(file_path, usage)

        if not aggregator.has_usage():
            self.stdout.write(self.style.WARNING("No hyperscript usage detected\n"))
            return

        # Get aggregated usage
        usage = aggregator.get_usage()

        # Apply extra commands/blocks from CLI
        extra_commands: set[str] = set()
        extra_blocks: set[str] = set()

        if options["extra_commands"]:
            extra_commands = {
                c.strip().lower() for c in options["extra_commands"].split(",")
            }

        if options["extra_blocks"]:
            extra_blocks = {b.strip().lower() for b in options["extra_blocks"].split(",")}

        # Apply settings from Django HYPERFIXI config
        hyperfixi_settings = getattr(settings, "HYPERFIXI", {})
        if hyperfixi_settings.get("EXTRA_COMMANDS"):
            extra_commands.update(
                c.lower() for c in hyperfixi_settings["EXTRA_COMMANDS"]
            )
        if hyperfixi_settings.get("EXTRA_BLOCKS"):
            extra_blocks.update(b.lower() for b in hyperfixi_settings["EXTRA_BLOCKS"])

        # Merge with detected usage
        all_commands = usage.commands | extra_commands
        all_blocks = usage.blocks | extra_blocks
        positional = (
            usage.positional
            or options["positional"]
            or hyperfixi_settings.get("POSITIONAL", False)
        )
        htmx = options["htmx"] or hyperfixi_settings.get("HTMX", False)

        # Validate commands and blocks
        unknown_commands = all_commands - VALID_COMMANDS
        if unknown_commands and verbose:
            self.stdout.write(
                self.style.WARNING(
                    f"Unknown commands (will be skipped): {sorted(unknown_commands)}\n"
                )
            )

        unknown_blocks = all_blocks - VALID_BLOCKS
        if unknown_blocks and verbose:
            self.stdout.write(
                self.style.WARNING(
                    f"Unknown blocks (will be skipped): {sorted(unknown_blocks)}\n"
                )
            )

        # Filter to valid only
        valid_commands = sorted(all_commands & VALID_COMMANDS)
        valid_blocks = sorted(all_blocks & VALID_BLOCKS)

        # Generate output
        output_format = options["format"]

        if output_format == "summary":
            output = self._format_summary(
                valid_commands,
                valid_blocks,
                positional,
                htmx,
                len(usage.file_usage),
            )
        elif output_format == "js-config":
            output = self._format_js_config(
                options["name"], valid_commands, valid_blocks, positional, htmx
            )
        else:  # json
            output = self._format_json(
                options["name"],
                valid_commands,
                valid_blocks,
                positional,
                htmx,
                list(usage.file_usage.keys()),
            )

        # Write output
        if options["output"]:
            output_path = Path(options["output"])
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(output)
            self.stdout.write(self.style.SUCCESS(f"Written to {output_path}\n"))
        else:
            self.stdout.write(output)

        # Summary
        self.stdout.write(
            self.style.SUCCESS(
                f"\nDetected: {len(valid_commands)} commands, {len(valid_blocks)} blocks, "
                f"positional={positional} across {len(usage.file_usage)} files\n"
            )
        )

    def _get_template_dirs(self, paths: list[str]) -> list[Path]:
        """Get template directories to scan."""
        if paths:
            return [Path(p) for p in paths if Path(p).exists()]

        dirs: list[Path] = []

        # Get from Django template engines
        for engine in engines.all():
            for template_dir in engine.dirs:
                dirs.append(Path(template_dir))

            # Also check app template directories
            if hasattr(engine, "engine") and hasattr(engine.engine, "dirs"):
                for template_dir in engine.engine.dirs:
                    dirs.append(Path(template_dir))

        # Check TEMPLATES setting directly
        for template_config in settings.TEMPLATES:
            for dir_path in template_config.get("DIRS", []):
                dirs.append(Path(dir_path))

        return [d for d in set(dirs) if d.exists()]

    def _format_summary(
        self,
        commands: list[str],
        blocks: list[str],
        positional: bool,
        htmx: bool,
        file_count: int,
    ) -> str:
        """Format as human-readable summary."""
        lines = [
            "",
            "HyperFixi Bundle Summary",
            "=" * 40,
            f"Commands ({len(commands)}): {', '.join(commands) if commands else 'none'}",
            f"Blocks ({len(blocks)}): {', '.join(blocks) if blocks else 'none'}",
            f"Positional: {positional}",
            f"HTMX: {htmx}",
            f"Files scanned: {file_count}",
            "",
            "Recommended bundle command:",
        ]

        # Build command
        cmd_parts = ["  npm run generate:bundle --"]
        if commands:
            cmd_parts.append(f"--commands {','.join(commands)}")
        if blocks:
            cmd_parts.append(f"--blocks {','.join(blocks)}")
        if positional:
            cmd_parts.append("--positional")
        if htmx:
            cmd_parts.append("--htmx")

        lines.append(" ".join(cmd_parts))
        lines.append("")

        return "\n".join(lines)

    def _format_js_config(
        self,
        name: str,
        commands: list[str],
        blocks: list[str],
        positional: bool,
        htmx: bool,
    ) -> str:
        """Format as JavaScript config object."""
        config_parts = [
            f'  name: "{name}",',
            f"  commands: {json.dumps(commands)},",
        ]
        if blocks:
            config_parts.append(f"  blocks: {json.dumps(blocks)},")
        if positional:
            config_parts.append("  positionalExpressions: true,")
        if htmx:
            config_parts.append("  htmxIntegration: true,")
        config_parts.append('  globalName: "hyperfixi"')

        return (
            "// Auto-generated by: python manage.py hyperfixi_bundle\n"
            + "const bundleConfig = {\n"
            + "\n".join(config_parts)
            + "\n};\n"
        )

    def _format_json(
        self,
        name: str,
        commands: list[str],
        blocks: list[str],
        positional: bool,
        htmx: bool,
        files: list[str],
    ) -> str:
        """Format as JSON config file."""
        config: dict = {
            "name": name,
            "commands": commands,
            "output": f"dist/hyperfixi-{name.lower()}.js",
            "globalName": "hyperfixi",
        }
        if blocks:
            config["blocks"] = blocks
        if positional:
            config["positionalExpressions"] = True
        if htmx:
            config["htmxIntegration"] = True

        # Include file list for reference (as metadata)
        config["_meta"] = {
            "generated_by": "hyperfixi_bundle",
            "file_count": len(files),
            "files": sorted(files)[:20],  # Limit to first 20
        }

        return json.dumps(config, indent=2) + "\n"
